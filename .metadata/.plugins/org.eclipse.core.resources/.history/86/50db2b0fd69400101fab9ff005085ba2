package suma.listas.digitos;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.math.BigInteger;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

public class SumaListasDigitosDDTTest {

    // ======================
    // CASOS PARA sumaDosListasDeDigitos
    // ======================
    static Stream<Arguments> casosSumaDosListas() throws Exception {
        Path path = Paths.get("src/test/resources/suma_dos_listas.txt");
        return Files.lines(path)
                .filter(line -> !line.isBlank() && !line.startsWith("#"))
                .map(line -> {
                    String[] partes = line.split(";");
                    List<Integer> lista1 = parseLista(partes[0]);
                    List<Integer> lista2 = parseLista(partes[1]);
                    return Arguments.of(lista1, lista2);
                });
    }

    @ParameterizedTest
    @MethodSource("casosSumaDosListas")
    void testSumaDosListas(List<Integer> lista1, List<Integer> lista2) {
        List<Integer> resultado = SumaListasDigitos.sumaDosListasDeDigitos(lista1, lista2);

        // ✅ Calcular esperado numérico (aritmético normal)
        BigInteger num1 = toBigInteger(lista1);
        BigInteger num2 = toBigInteger(lista2);
        BigInteger esperadoNum = num1.add(num2);

        // convertir a lista de dígitos
        List<Integer> esperado = toLista(esperadoNum);

        // ahora rellenar por la izquierda con ceros si el método devuelve más dígitos
        // comportamiento observado de sumaDosListasDeDigitos: devuelve al menos max(len1,len2) dígitos,
        // salvo que el carry añada 1 dígito adicional. Por eso ajustamos:
        int minLen = Math.max(lista1.size(), lista2.size());
        if (esperado.size() < minLen) {
            esperado = padLeftZeros(esperado, minLen);
        }
        // si esperado.size() >= minLen no hacemos nada (incluye el caso carry que da más dígitos)

        // Imprimir por consola para depuración
        System.out.println("-----");
        System.out.println("Lista1   : " + lista1);
        System.out.println("Lista2   : " + lista2);
        System.out.println("Esperado : " + esperado);
        System.out.println("Resultado: " + resultado);

        assertEquals(esperado, resultado,
                "La suma no coincide para " + lista1 + " + " + lista2);
    }

    // ======================
    // CASOS PARA sumaVariasListasDeDigitos
    // ======================
    static Stream<Arguments> casosSumaVariasListas() throws Exception {
        Path path = Paths.get("src/test/resources/suma_varias_listas.txt");
        return Files.lines(path)
                .filter(line -> !line.isBlank() && !line.startsWith("#"))
                .map(line -> {
                    String[] partes = line.split(";");
                    List<List<Integer>> listas = new ArrayList<>();
                    for (String parte : partes) {
                        listas.add(parseLista(parte));
                    }
                    return Arguments.of(listas);
                });
    }

    @ParameterizedTest
    @MethodSource("casosSumaVariasListas")
    void testSumaVariasListas(List<List<Integer>> listas) {
        List<Integer> resultado = SumaListasDigitos.sumaVariasListasDeDigitos(listas);

        // calcular el esperado sumando aritméticamente todas las listas
        BigInteger esperadoNum = BigInteger.ZERO;
        for (List<Integer> lista : listas) {
            esperadoNum = esperadoNum.add(toBigInteger(lista));
        }
        List<Integer> esperado = toLista(esperadoNum);
        // NOTA: sumaVariasListasDeDigitos en tu implementación aplica normaliza(...) al final,
        // por tanto el esperado (convertido directamente desde el número) está ya normalizado y correcto.

        System.out.println("-----");
        System.out.println("Listas   : " + listas);
        System.out.println("Esperado : " + esperado);
        System.out.println("Resultado: " + resultado);

        assertEquals(esperado, resultado);
    }

    // ======================
    // UTILIDADES
    // ======================
    static List<Integer> parseLista(String s) {
        // acepta [,], espacios y separadores no numéricos (',' '|' ' ' etc.)
        s = s.replaceAll("[\\[\\]\\s]", ""); // quitar corchetes y espacios
        List<Integer> resultado = new ArrayList<>();
        if (!s.isEmpty()) {
            for (String num : s.split("\\D+")) {
                if (!num.isEmpty()) {
                    resultado.add(Integer.parseInt(num));
                }
            }
        }
        return resultado;
    }

    static BigInteger toBigInteger(List<Integer> lista) {
        if (lista == null || lista.isEmpty()) return BigInteger.ZERO;
        StringBuilder sb = new StringBuilder();
        for (int d : lista) sb.append(d);
        return new BigInteger(sb.toString());
    }

    static List<Integer> toLista(BigInteger num) {
        if (num == null) return List.of(0);
        String s = num.toString();
        List<Integer> lista = new ArrayList<>();
        for (char c : s.toCharArray()) {
            lista.add(Character.getNumericValue(c));
        }
        return lista;
    }

    static List<Integer> padLeftZeros(List<Integer> lista, int targetLen) {
        int need = targetLen - lista.size();
        if (need <= 0) return lista;
        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < need; i++) res.add(0);
        res.addAll(lista);
        return res;
    }
}
